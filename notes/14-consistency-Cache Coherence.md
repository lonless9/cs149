# CS149: 并行计算 - 第14讲：内存一致性模型

本讲深入探讨共享内存多处理器系统中的内存一致性模型，这是决定多线程程序行为的核心规范。我们将回顾缓存一致性，引入内存一致性的概念，并详细讨论各种一致性模型及其对程序行为和性能的影响。

## 1. 缓存一致性回顾

虽然缓存一致性已在第13讲详细讨论，但为理解内存一致性，我们需要先明确二者的区别：

### 1.1 缓存一致性的核心问题

缓存一致性解决的是**同一内存位置**的多个副本在多个处理器缓存中如何保持一致：

- **根本问题**：当多个处理器在本地缓存中复制同一内存地址的数据时，如何确保数据更新对所有处理器可见
- **目标**：确保对特定内存位置的写入最终对所有处理器可见，就像系统没有缓存一样
- **关键特性**：维护单写多读(SWMR)原则和数据值不变性

缓存一致性协议（如MSI、MESI等）就是为解决这一问题而设计的，它们确保了系统中的每个缓存行在任何时刻都处于协调的状态。

## 2. 内存一致性模型的引入

### 2.1 从缓存一致性到内存一致性

虽然缓存一致性确保了对单个内存位置的操作最终一致，但它没有定义**不同内存位置**之间的操作顺序，这正是内存一致性模型需要解决的问题：

| 方面 | 缓存一致性 (Cache Coherence) | 内存一致性 (Memory Consistency) |
|------|---------------------------|------------------------------|
| 关注点 | 单个内存位置的访问顺序 | 所有内存位置访问的表观顺序 |
| 核心问题 | "最终看到写入" | "何时看到写入" |
| 范围 | 硬件实现细节 | 程序行为规范 |
| 存在条件 | 仅在有缓存时相关 | 与缓存无关，即使无缓存系统也需要 |

### 2.2 内存一致性模型的定义与重要性

**内存一致性模型**是定义多处理器系统中内存操作执行顺序的规范，它解答的核心问题是：

> 当多个线程同时对不同内存位置进行操作时，这些操作以何种顺序被执行并对其他线程可见？

其重要性体现在：

- **可编程性**：影响程序员如何推理多线程程序行为
- **性能**：决定硬件和编译器可以采用哪些优化（尤其是操作重排序）
- **正确性**：对于实现同步库、操作系统内核、无锁数据结构等至关重要

## 3. 内存操作排序基础

### 3.1 重排序的动机

现代处理器会对内存操作进行重排序，主要原因是：

- **隐藏内存访问延迟**：特别是写操作和缓存未命中的读操作
- **提高指令级并行性**：允许独立操作并行执行
- **优化资源利用**：如合并写操作，避免总线争用

### 3.2 操作排序类型

内存一致性模型关注四种基本内存操作排序是否必须维持：

1. **W→R（写后读）**：写X后读Y的顺序
2. **R→R（读后读）**：读X后读Y的顺序
3. **R→W（读后写）**：读X后写Y的顺序
4. **W→W（写后写）**：写X后写Y的顺序

其中，X和Y是不同的内存位置，操作来自同一处理器，"→"表示程序顺序。

```
// 程序顺序示例
A = 1;    // 写A (W_A)
r1 = B;   // 读B (R_B)
C = r1;   // 写C (W_C)
r2 = D;   // 读D (R_D)

// 排序约束：
// W_A → R_B (写后读)
// R_B → W_C (读后写)
// W_C → R_D (写后读)
```

## 4. 顺序一致性模型

### 4.1 顺序一致性定义

**顺序一致性(Sequential Consistency, SC)**是最直观也最严格的内存模型，由Lamport在1979年提出：

> "多处理器系统的执行结果如同所有操作按照某个串行顺序执行，且每个处理器内部的操作顺序与其程序顺序一致。"

形象来说，SC模型就像有一个单一的"开关"控制器，每次从某个处理器中选择一个操作**原子地、完整地**执行，确保全局看到一个一致的执行序列。

### 4.2 顺序一致性实例

考虑两个处理器P1和P2的交互：

```
// 初始状态: X = Y = 0

// P1执行:        // P2执行:
X = 1;            Y = 1;
r1 = Y;           r2 = X;
```

在SC模型下，可能结果有三种：
- `r1 = 0, r2 = 1`：先执行P1的`X = 1`，再执行P2的所有操作，最后执行P1的`r1 = Y`
- `r1 = 1, r2 = 0`：先执行P2的`Y = 1`，再执行P1的所有操作，最后执行P2的`r2 = X`
- `r1 = 1, r2 = 1`：先执行P1的`X = 1`，再执行P2的`Y = 1`，然后执行两个读操作

但SC模型下不可能出现`r1 = 0, r2 = 0`的结果，因为不存在合法的串行执行顺序会产生此结果。

### 4.3 顺序一致性的限制

虽然SC模型直观且易于理解，但它严重限制了性能优化：

- **写操作延迟问题**：写操作通常延迟较高，SC要求后续操作等待写完成
- **指令级并行受限**：即使独立于先前的写操作，后续读也必须等待
- **缓存利用率降低**：需要频繁同步缓存状态

由于这些限制，实际处理器通常实现更放松的一致性模型。

## 5. 放松一致性模型

### 5.1 写后读重排序(W→R)与写缓冲器

最常见的内存重排序是允许读操作越过之前的写操作执行，这通过**写缓冲器**实现：

- **机制**：处理器写入时，数据先放入本地写缓冲器，处理器可继续执行
- **效果**：写操作对执行它的处理器"立即"完成，对其他处理器延迟可见

#### 5.1.1 TSO(Total Store Order)模型

**TSO**是Intel x86/x64等处理器采用的一致性模型：
- 允许W→R重排序：处理器可在写入X全局可见前读取Y
- 维持其他约束(R→R, R→W, W→W)
- 写入对执行它的处理器立即可见(Store Forwarding)

TSO可能导致违反直觉的行为：

```
// 初始状态: X = Y = 0

// P1执行:        // P2执行:
X = 1;            Y = 1;
r1 = Y;           r2 = X;

// 可能结果: r1 = r2 = 0
// 解释: P1的X=1和P2的Y=1都在写缓冲器中，
//      二者的读操作在写全局可见前执行
```

#### 5.1.2 写回写分配的影响

写回(write-back)缓存配合写缓冲会进一步影响可见性：
- 写入先进入写缓冲器，然后写入本地缓存
- 直到发生缓存替换或一致性事件时，才写回到内存
- 增加了写操作对其他处理器可见的延迟

### 5.2 其他放松模型

#### 5.2.1 PSO(Partial Store Order)

PSO放松了W→W约束，允许写操作之间的重排序：
- 维持R→R, R→W, 部分W→R约束
- 对执行两个独立写操作的指令很有用
- 可以由优化的写缓冲器实现(如优先处理命中)

```
// 在PSO下，以下写操作可能被重排
X = 1;
Y = 2;
// Y的写入可能先于X的写入对其他处理器可见
```

#### 5.2.2 WO(Weak Ordering)和RC(Release Consistency)

这些模型放松所有四种排序约束：
- 内存操作可任意重排，除非被同步操作分隔
- 读操作尽可能早执行，写操作尽可能晚执行
- 显著提高性能，但需要显式同步来保证顺序

### 5.3 内存屏障与同步原语

为控制内存重排序，硬件提供特殊指令：

- **内存屏障(Memory Barrier/Fence)**：强制在屏障前的操作完成后，才能执行屏障后的操作
  - **读屏障**：确保屏障前的读操作先于屏障后的操作完成
  - **写屏障**：确保屏障前的写操作先于屏障后的操作完成
  - **全屏障**：同时为读和写操作提供保证

- **平台特定实现**：
  - **x86/x64**：`lfence`(读屏障), `sfence`(写屏障), `mfence`(全屏障)
  - **ARM**：`dmb`(数据内存屏障), `dsb`(数据同步屏障)

- **原子操作**：如`compare-and-swap`, `fetch-and-add`等，通常隐含内存屏障效果

## 6. 数据竞争与同步程序

### 6.1 数据竞争定义

**数据竞争**发生在满足以下所有条件时：
1. 程序中存在对同一内存位置的两次访问
2. 至少一次访问是写操作
3. 这两次访问没有被同步操作排序

```c
// 数据竞争示例
int counter = 0;  // 共享变量

// 线程1
counter++;  // 读取counter，加1，写回counter

// 线程2
counter++;  // 同样的操作，可能与线程1并发

// 由于没有同步，可能导致更新丢失
```

### 6.2 数据竞争避免程序(DRF)

**数据竞争避免(Data-Race-Free, DRF)**程序通过使用同步原语确保所有冲突访问都被排序：

```c
// 使用互斥锁避免数据竞争
int counter = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// 线程1
pthread_mutex_lock(&mutex);
counter++;
pthread_mutex_unlock(&mutex);

// 线程2
pthread_mutex_lock(&mutex);
counter++;
pthread_mutex_unlock(&mutex);
```

### 6.3 SC for DRF保证

现代硬件和编程语言提供**SC for DRF**保证：
- 如果程序是数据竞争避免的，它在任何一致性模型上的执行结果与SC模型相同
- 编译器和硬件自动在必要位置插入内存屏障来确保这一保证
- 这使程序员可以按SC模型推理无竞争程序，同时获得放松模型的性能

## 7. 语言级内存模型

### 7.1 编译器优化与内存一致性

不仅硬件，编译器也会进行内存操作重排序优化：
- 将循环不变量的加载移出循环
- 删除冗余加载
- 重排指令以提高寄存器利用率

这些优化在单线程程序中通常不可见，但在多线程环境下可能改变程序行为。

### 7.2 主流语言的内存模型

现代编程语言定义了内存模型来规范多线程行为：

- **C11/C++11**：
  - 默认情况下变量访问没有同步保证(memory_order_relaxed)
  - 提供原子类型和内存序选项(memory_order_acquire/release/seq_cst)
  - 保证DRF程序的SC行为

- **Java**：
  - 默认变量访问为非原子的
  - volatile变量提供可见性保证
  - synchronized和java.util.concurrent类库提供完整同步
  - 保证DRF程序的SC行为

- **核心理念**：鼓励程序员使用语言/库提供的同步机制，避免直接依赖底层硬件内存模型

### 7.3 未定义行为

对于包含数据竞争的程序，大多数语言定义其行为为"未定义"(undefined)：
- 可能导致任何结果，包括程序崩溃或错误数据
- 编译器可以假设程序没有数据竞争，并基于此假设进行激进优化
- 编译器不承诺在有竞争时提供任何保证

## 8. 实际编程中的一致性考虑

### 8.1 常见并发模式的一致性需求

不同并发编程模式对内存一致性有不同要求：

- **基于锁的同步**：
  - 锁获取需要acquire语义(确保后续操作不会被移到锁前)
  - 锁释放需要release语义(确保前面操作不会被移到锁后)

- **生产者-消费者模式**：
  - 生产者写入数据后的flag更新需要release语义
  - 消费者检测flag后的数据读取需要acquire语义

- **无锁数据结构**：
  - 通常依赖原子操作和内存屏障的精确组合
  - 需要深入理解底层内存模型

### 8.2 性能与正确性平衡

内存一致性涉及性能与正确性的平衡：

- **过度同步**导致性能下降
- **同步不足**导致微妙且难以调试的错误
- **最佳实践**：使用高级同步库和数据结构，它们已经正确处理了内存一致性问题

## 9. 总结

内存一致性模型是多处理器系统中决定共享内存行为的重要规范：

- **缓存一致性**关注"最终看到写入"，而**内存一致性**关注"何时看到写入"
- **顺序一致性**提供最直观但性能受限的模型
- **放松一致性模型**(TSO, PSO, WO等)通过允许重排序提升性能
- **内存屏障和同步原语**用于在需要时强制执行操作顺序
- **数据竞争避免程序**在任何一致性模型上都获得SC行为
- **语言级内存模型**提供了程序员与系统之间的契约

理解内存一致性对于开发高性能、正确的并行程序至关重要，尤其是在开发低级系统软件、同步库和无锁数据结构时。一般应用程序开发者可以通过使用标准同步库来避免直接处理这些复杂性。 